WARNING: Under construction

STL on embedded/realtime systems
===========================================================

  - STL stands for "Standard Template Library"
  - Generic interface for *data structures* and *algorithms*.
  - *Data structures* are presented in the form of containers.
  - *Algorithms* are usually free functions that act on iterators.
  - Containers provide iterators to be used with algorithms.

  STL = containers + iterators + algorithms + ....

  Example: Sort a vector

  std::vector<int> v = {6, 3, 2, 4, 15, 1, 7, 1, 9, 80};

  std::sort(std::begin(v), std::end(v));
  bool b = std::binary_search(std::begin(v), std::end(v), 9);
  ...

===========================================================

  Containers are divided in many groups according to their properties.

  (A) Sequence containers

  std::vector - std::array - std::deque - std::list - std::forward_list.

  (B) Associative containers

  std::set - std::multiset - std::map - std::multimap

  (C) Unordered associative containers

  - std::unordere_set - std::unordere_map -std::unordered_multiset
    std::unordered_multimap

===========================================================

How are containers implemented?

  - Not specified by the standard. Only complexity guarantees
    for its member functions are provided (Big O).
    
  - Take insertion at an arbitrary position as an example.

    - std::list: O(1)
    - std::map: O(log(n))
    - std::vector: O(n)

===========================================================

Algorithms

  - Do not operate on containers, but rather on iterators.
  - Depending on the kind of iterators they are called with,
    performance it improved. Example
  
    auto iter = std::binary_search(std::begin(l), std::end(l));
  
    is faster if l is a std::vector instead of a list.
  
  - So what kind of iterators there are?
    - input and output: iostreams.
    - Forward: std::forward_list, std::unordered_set, etc.
    - Bidirectional: std::list, std::set, ...
    - Random access:: std::vector, std::array, std::deque.

===========================================================

Should you use STL for development? Why?

  - Yes, by default.
  - Makes your intentions obvious.
    

    int n = std::count(std::begin(v), std::end(v), 10);
    auto m = std::max_element(std::begin(v), std::end(v), 10);

  - Designed by experts, high quality implementations, tested.
  - You do not want to reinvent the square will.
  - It is very unlikely you need a general purpose algorithm
    that is not here.

===========================================================

Realtime guarantees - Where the problem begins.

===========================================================

Memory in a program (simplified)

  There are two main "places" in a program where we can store our data
  during program execution:
  
  A) The Stack. Grows towards lower memory addresses.
  B) The Heap. Grows towards higher memory addresses.

  Diagram:

  |         Heap                                        Stack        | 
  |     ---------->                                  <----------     |  
  |__________________________________________________________________|
  0                                                               192873
                       Program address space


Memory allocation on the stack and heap
===========================================================

  A) Stack.

  - Allocation and deallocation is automatic and have no overhead.
  - Only a pointer is adjusted.
  - Limited capacity.
  - Lifetime limited to the function scope where the variable was
    allocated (declared).

  Example:

  int a; // Allocates space for an integer on the stack.

  B) Heap.
  
  - Explicitly requested by the programmer through operator new or malloc.
  - The algorithm used to find space is not standardized (platform dependent).
  - Space is requested to the operating system through system calls.
  - Even though the whole complexity is hidden from the programmer,
    behind his back there are many things going on.
  - Usually unpredictable performance. Depends on things like fragmentation.

  Example:

  T* t = new T; // find space for sizeof (T) on the heap.

Back to c++ containers
===========================================================

There are two main types of container in c++.

  A) Sequential allocation.

    Consecutive elements are in consecutive memory addresses.

    Example:

    int a[10];             // Built in the language.
    std::array<int, 10> a; // Library container. Fixed size.
    std::vector<int> a;    // Library container. Variable size. 

  B) Linked allocation.

  All other containers. There is no ordering regarding memory addresses.  They
  can be divided in many categories according to operations and complexity
  guarantees they provide.

Where do containers store their elements?
===========================================================

  - Built-in arrays and std::array use exclusively the stack.
  - All other containers request memory from their allocator.

  std::vector<int, std::allocator<int>> a;

