
Using STL on embedded systems
===========================================================

  - STL stands for "Standard template library"
  - Privides users with *data structures* and *algorithms*.
  - *Data structures* are presented in the form of containers.

  (A) Sequential memory allocation (almost for std::deque)

  std::vector - std::array - std::deque
  ===> std::flat_set, std::flat_map, etc. (likely to be aceepted)

  (B) Linked allocation

  std::list - std::forward_list
  std::set - std::multiset - std::unordere_set - std::unordered_multiset
  std::map - std::multimap - std::unordere_map - std::unordered_multimap

===========================================================

How are containers implemented?

- Not specified by the standard. Only complexity guarantees
  for its member functions are provided (Bit O). For example,
  The complexity guarantees of insertion operation at an arbitrary
  position are:

  - std::list: O(1)
  - std::map: O(log(n))
  - std::vector: O(n)

- Important: The memory use complexity is not specified
  (Bad for embedded developers).

===========================================================

Algorithms

- The other important part are algorithms.
- They do not operate on containers, but on iterators.
- Depending on the kind of iterators they are called with,
  performance it improved. Example

  auto iter = std::binary_search(std::begin(l), std::end(l));

  is faster is l is a std::vector instead of a list.

- So what kind of iterators there are?
  - input and output: iostreams.
  - Forward: std::forward_list, std::unordered_set, etc.
  - Bidirectional: std::list, std::set, ...
  - Random access:: std::vector, std::array, std::deque.

===========================================================

Examples

===========================================================

Seems enough to 

===========================================================


Memory in a program (simplified)
===========================================================

  There are two main "places" in a program where we can store our data
  during program execution:
  
  A) The Stack. Grows towards lower memory addresses.
  B) The Heap. Grows towards higher memory addresses.

  Diagram:

  |         Heap                                        Stack        | 
  |     ---------->                                  <----------     |  
  |__________________________________________________________________|
  0                                                               192873
                       Program address space


Memory allocation on the stack and heap
===========================================================

  A) Stack.

  - Allocation and deallocation is automatic and have no overhead.
  - Only a pointer is adjusted.
  - Limited capacity.
  - Lifetime limited to the function scope where the variable was
    allocated (declared).

  Example:

  int a; // This allocates space for an integer on the stack.

  B) Heap.
  
  - Explicitly requested by the programmer through operator new or malloc.
  - The algorithm used to find space is not standardized (platform dependent).
  - Space is requested to the operating system through system calls.
  - Even though the whole complexity is hidden from the programmer,
    behind his back there are many things going on.
  - Usually unpredictable performance. Depends on things like fragmentation.

  Example:

  T* t = new T; // find space for sizeof (T) on the heap.

Back to c++ containers
===========================================================

There are two main types of container in c++.

  A) Sequential allocation.

    Consecutive elements are in consecutive memory addresses.

    Example:

    int a[10];             // Built in the language.
    std::array<int, 10> a; // Library container. Fixed size.
    std::vector<int> a;    // Library container. Variable size. 

  B) Linked allocation.

  All other containers. There is no ordering regarding memory addresses.  They
  can be divided in many categories according to operations and complexity
  guarantees they provide.

Where do containers store their elements?
===========================================================

  - Built-in arrays and std::array use exclusively the stack.
  - All other containers request memory from their allocator.

  std::vector<int, std::allocator<int>> a;

