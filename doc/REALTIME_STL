WARNING: Under construction

STL on embedded/realtime systems
===========================================================

  - STL stands for "Standard Template Library"

  - Generic interface for *data structures* and *algorithms*.

  - *Data structures* are presented in the form of containers.

    std::vector, std::list, std::map, std::set, etc.

  - *Algorithms* are provided as member and non-member functions.

    Member: std::list<int>::sort, std::set<int>::find, etc.
    Non-Free: std::sort, std::find, etc.

  - Non-member algorithms do not interact directly with containers,
    they act on iterators.

    std::sort(std::begin(v), std::end(v));

  - There are five types of iterators: Input, output, forward,
    bidirectional and random access iterators.
    Think of them as generalization of pointers.

  STL = containers + iterators + algorithms + ....

===========================================================

  Containers are group together according to their properties.
  Most important properties:

  (A) Elements ordering and access
  (B) Iterators they provide.
  (C) Memory use: Linked or sequential allocation.

  Sequence containers

    std::vector - std::array - std::deque - std::list - std::forward_list.

  Ordered associative containers

    std::set - std::multiset - std::map - std::multimap

  Unordered associative containers

    std::unordere_set - std::unordere_map -std::unordered_multiset
    std::unordered_multimap

===========================================================

Containers classified according to the iterators they provide.

  Input/Output ===> Most important for streams.

  Forward: *p, ++p;

    std::forward_list
    std::unordere_set
    std::unordere_map
    std::unordered_multiset
    std::unordered_multimap

  Bidirectional: *p, ++p, --p.

    std::list
    std::set
    std::multiset
    std::map
    std::multimap

  Random Access. *p, ++p, --p, p[n].

    std::vector
    std::array
    std::deque

===========================================================

Memory use: Linked or sequential allocation.

  A) Sequential allocation.

    Consecutive elements are in consecutive memory addresses.

    Example

    int a[10];             // Built in the language.
    std::array<int, 10> a; // Library container. Fixed size.
    std::vector<int> a;    // Library container. Variable size. 

  B) Linked allocation. All other containers. 

  - No ordering regarding memory addresses.
  - Nodes pointing to each other.
  - Allocate blocks that always have the same size.

===========================================================

How are containers implemented?

  Not specified by the standard. Only complexity guarantees
  for its member functions are provided (Big O).
    
  Take insertion at an arbitrary position as an example.

    - std::list: O(1)
    - std::map: O(log(n))
    - std::vector: O(n)

  Memory use not specified.

  - Does std::sort allocates auxiliary buffers?

===========================================================

Should you use STL for development? Why?

  - Yes, by default.
  - Makes your intentions obvious.

    int n = std::count(std::begin(v), std::end(v), 10);

  - Designed by experts, high quality implementations, tested.
  - You do not want to reinvent the square will.
  - It is very unlikely you need a general purpose algorithm
    that is not here.

===========================================================

Realtime guarantees - Where the problem begins.

===========================================================

Memory in a program (simplified)

  There are two main "places" in a program where we can store our data
  during program execution:
  
  A) The Stack. Grows towards lower memory addresses.
  B) The Heap. Grows towards higher memory addresses.

  Diagram:

  |         Heap                                        Stack        | 
  |     ---------->                                  <----------     |  
  |__________________________________________________________________|
  0                                                               192873
                       Program address space


Memory allocation on the stack and heap
===========================================================

  A) Stack.

  - Allocation and deallocation is automatic and have no overhead.
  - Only a pointer is adjusted.
  - Limited capacity.
  - Lifetime limited to the function scope where the variable was
    allocated (declared).

  Example:

  int a; // Allocates space for an integer on the stack.

  B) Heap.
  
  - Explicitly requested by the programmer through operator new or malloc.
  - The algorithm used to find space is not standardized (platform dependent).
  - Space is requested to the operating system through system calls.
  - Even though the whole complexity is hidden from the programmer,
    behind his back there are many things going on.
  - Usually unpredictable performance. Depends on things like fragmentation.

  Example:

  T* t = new T; // find space for sizeof (T) on the heap.

Where do containers store their elements?
===========================================================

  - Built-in arrays and std::array use exclusively the stack.
  - All other containers request memory from their allocator.

  std::vector<int, std::allocator<int>> a;

