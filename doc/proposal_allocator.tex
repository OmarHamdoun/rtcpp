\documentclass[11pt]{article}
\usepackage{tikz}
\usepackage{pifont}
\usepackage{amsmath}
\usepackage{marvosym}
\usepackage{verbatim}
\usepackage{listings}
\usepackage[utf8]{inputenc}
\usepackage{subfig}
\usepackage[switch,columnwise]{lineno}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage[nottoc,numbib]{tocbibind}
   
\usepackage{hyperref}
\hypersetup{
bookmarks=false,         % show bookmarks bar?
unicode=true,          % non-Latin characters in Acrobat's bookmarks
pdftoolbar=true,        % show Acrobat's toolbar?
pdfmenubar=true,        % show Acrobat's menu?
pdffitwindow=true,     % window fit to page when opened
pdfstartview={FitH},    % fits the width of the page to the window
pdftitle={Node allocators},    % title
pdfauthor={Marcelo Zimbres},     % author
pdfsubject={C++ allocators},   % subject of the document
pdfcreator={Marcelo Zimbres},   % creator of the document
pdfproducer={Marcelo Zimbres}, % producer of the document
pdfkeywords={allocators} {C++}, % list of keywords
pdfnewwindow=true,      % links in new window
colorlinks=true,        % false: boxed links; true: colored links
linkcolor=red,          % color of internal links
citecolor=red,        % color of links to bibliography
filecolor=red,      % color of file links
linktocpage=true,
urlcolor=blue           % color of external links
}

\lstset{
  language=C++,                 % the language of the code
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  keywordstyle=\color{blue},       % keyword style
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{blue},       % comment style
  deletekeywords={},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  morekeywords={using, static_assert},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=10pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{black}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{red},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\colorlet{blah}{brown!60!black} % box color

\begin{document}

\date{}
\title{\vspace{-2cm} \bf Improving allocator interface for node-based containers}
\maketitle
\noindent
\vspace{-1cm} \\
{\bf Document number}:  1 \\
{\bf Date}:  \today \\
{\bf Project}: Programming Language C++ \\
{\bf Author}: Marcelo Zimbres (\href{mailto:mzimbres@gmail.com}{mzimbres@gmail.com}) 

\vspace{1cm}

\noindent
{\bf Abstract: }This is a non-breaking proposal to the C++ standard that aims
to reduce allocator complexity, support realtime allocation and improve
performance of node-based containers by making a clear distinction between {\it node}
and {\it array} allocation in the \texttt{std::allocator\_traits} interface.
Two new member functions are proposed \texttt{allocate\_node} and
\texttt{deallocate\_node}. We also propose that the container node type should
be exposed to the user. A prototype implementation is provided.

\tableofcontents

\vfill
%\newpage
%\twocolumn
%\linenumbers
\begin{flushright}
\noindent
{\it Size management adds undue difficulties \\
     and inefficiencies to any allocator design} \\
A. ALEXANDRESCU \\
\medskip
{\it }
\end{flushright}
\medskip

\section{Introduction}
\textsc{The importance} of linked data structures in computer science, like
trees and linked lists, cannot be over-emphasised, yet, in the last couple of
years it has become a common trend in C++ to move away from such data
structures due to their sub-optimal memory access patterns \cite{middleditch,
chandler, meyers}.  In fact, many people today prefer to use the flat
alternatives and pay $O(n)$ insertion time, than $O(1)$ at the cost of memory
fragmentation and unpredictable performance loss.  

We believe in fact, that the ``{\it Don't pay for what you don't use}" premise
is not being met on node-based containers due to the restrictive
array-oriented allocator interface. This proposal tries to fix what the author
believes to be the root of problem: {\it The lack of distinction between array
and node allocation}.  We propose here a complete split between these two
allocation techniques by means of a non-breaking addition to
\texttt{std::allocator\_traits}
\medskip
\begin{lstlisting}
template<class Alloc>
struct allocator_traits {
  ...
  // Equal to Alloc::node_allocation_only if present,
  // std::false_type otherwise.
  using node_allocation_only = std::false_type

  // Calls a.allocate_node() if present otherwise calls
  // Alloc::allocate(1). Memory allocate with this function
  // must be deallocated with deallocate_node.
  pointer allocate_node(Alloc& a);

  // Calls a.deallocate_node(pointer) if present otherwise
  // calls Alloc::deallocate(p, 1). Can only be used with
  // memory allocated with allocate_node.
  void deallocate_node(Alloc& a, pointer p);
};
\end{lstlisting}
%The behaviour of these new members is better explained in section \ref{impact}.
These additions provide the following options inside node-based
containers
\begin{enumerate}
\item {\bf Array allocation only}.
This is the {\it status quo}. Libraries can continue to call
\texttt{allocate(n)} if they want, but since the majority of implementations
use $n = 1$, they may simply be implemented in terms of
\texttt{allocate\_node()}, regardless of whether the allocator provides this
function or not. The implementation of \texttt{allocate\_node()} in
\texttt{std::allocator\_traits} should fall back to \texttt{allocate(1)} 
when the allocator does not provide one.

\item {\bf Node allocation only}.
In this case, the user is required to set the typedef \texttt{node\_allocation\_only}
to \texttt{std::true\_type} in the allocator and provide \texttt{allocate\_node()}. The user is
not required to provide \texttt{allocate(n)}.
\item {\bf Array and node allocation together}. It is possible to use
both array {and} node allocation when the user provides \texttt{allocate\_node}
and sets \texttt{node\_allocation\_only} to \texttt{std::false\_type}.
I am unaware if this option is useful.
\end{enumerate}

\medskip
\noindent
{\bf Exposing the node type}. Even though the changes proposed above are enough
to achieve efficient node allocation, we still have no direct means of knowing
the allocation size i.e. the node size. This information is not available at
compile time and at runtime only when the rebound allocator instance is
constructed on container construction. It is a tricky operation that can be
avoided if we expose the container node type.

Another situation where the node type is useful is when implementing node allocators
for unordered containers. Usually, unordered containers rebound twice and there is
no way of knowing which rebound type is used for array and node allocation. Once
the node type is exposed it is easy to detect the type that will be used for node
allocation for example. We require that the exposed node type support SCARY 
initialization \cite{scary}. The following should hold
\medskip
\begin{lstlisting}
using node_type1 = std::set<int, C1, A1>::node_type;
using node_type2 = std::set<int, C2, A1>::node_type;
using node_type3 = std::set<int, C1, A2>::node_type;

static_assert(std::is_same<node_type1, node_type2>::value, "");
static_assert(std::is_same<node_type1, node_type3>::value, "");
static_assert(std::is_same<node_type2, node_type3>::value, "");
\end{lstlisting}

\medskip
\noindent
{\bf Example}. The example below uses the proposed features
to write code that is fast and uses the minimum amount of memory.
Many linked lists served with nodes stored in an \texttt{std::array.}
It is not possible to write it portably in current C++.
\newpage
\medskip
\begin{lstlisting}
  using alloc_t = rt::node_allocator<int>;

  using node_type = typename std::list<int, alloc_t>::node_type;

  // Buffer for 100 elements. offset is a space reserved for
  // the allocator (three computer words in my implementation).
  std::size_t node_size = sizeof (node_type);
  std::array<char, offset + 100 * node_size> buffer = {{}};

  alloc_t alloc(buffer);

  std::list<int, alloc_t> l1(alloc);
  std::list<int, alloc_t> l2(alloc);
  ...
  // Inserts elements. Allocation and deallocation implemented
  // with 6 lines of code (see below). Faster and simpler than
  // any allocator I could find.
  l1 = {27, 1, 60};
  ...
\end{lstlisting}

\medskip
\noindent
{\bf Alternative approach}. For an alternative approaches to support
node allocation, please see appendix \ref{alternative}.

\section{Motivation and scope}

Consider the example from last section where a programmer needs an
\texttt{std::list} to store some ($\approx 100$) integers somewhere
in the code. In current C++, there are two ways to do this (if we want
to use a standard container). We can simply use the standard allocator
\texttt{std::list<int>}.  This is undesirable for many reasons
\begin{enumerate}
\item Nodes go on the heap. For only 100 elements I would preferably
use the stack.
\item The node size is small ($\approx 20$bytes), it is not recommended
allocating them individually on the heap. Fragmentation begins to play a role
if I have many lists (or bigger n).
\item Suboptimal allocation behind \texttt{malloc}. It does not
know we are doing node allocations and cannot optimize it.
\item Unknown allocated size. Does it allocate more space to store information
needed by the algorithm? How much memory I am really using?
%\item The \texttt{malloc} implementation is platform dependent and can lead
%to deferent behaviours in different platforms.
\item  Each heap allocation is an overhead: all the code inside malloc, plus
system calls and allocation strategies. (I only need 20bytes of space for a
node!)
\end{enumerate}

All this is overkill for a simple list with a couple of elements
(for bigger n situation gets worser). At this point we think it is
better to use a custom allocator like in the example from last section.
This approach has a number of advantages
\begin{enumerate}
\item Nodes on the stack with optimal size. {\it You do not pay for space you do not use}.
\item Compact buffer, improving cache locality and causing
minimal fragmentation.
\item No allocation overhead: I only change some pointers. (See below)
\end{enumerate}

This is however not possible in the current allocator interface
due to the fact that \texttt{allocate(n)} may be called with $n \ne 1$,
that means I have to add unnecessary complexity to handle the many possible
values of n. The size of the buffer is not anymore clear and depends on the
allocation strategy/algorithm. All the added complexity is pointless. This is
only one use case out of many.

\medskip
\noindent
{\bf General motivations}. Some further motivations for this proposal are listed
below.
\begin{enumerate}

\item Support the most natural and one of the fastest allocation
scheme for linked data structures. In \texttt{libstd++} and
\texttt{libc++} for example, it is already possible (by chance) to use
this allocation technique, since $n$ is always $1$ on calls of
\texttt{allocate(n)}.

\item Node-based containers do not manage allocation sizes but
unnecessarily demand this feature from their allocators, with a cost
in performance and complexity.

%(Unordered associative containers use
%sized allocations in addition to node allocation, which means they
%need the sized version of \texttt{allocate} as well, but for purposes
%other than node allocation).

\item Support hard-realtime allocation for node-based containers
through pre-allocation and pre-linking of nodes. This is highly
desirable to improve C++ usability in embedded systems.

\item State of the art allocators like \texttt{boost::node\_allocator}
\cite{boost} achieve great performance gains optimizing for the $n = 1$ case. 

\item Avoid wasted space behind allocations. It is pretty common that
allocators allocate more memory than requested to store information
like the size of the allocated block.

\item Keep nodes in as-compact-as-possible buffers, either on the
stack or on the heap, improving cache locality, performance and making
them specially useful for embedded programming.

\end{enumerate}

%A question that naturally arises is: {\it Why not simply test
%whether $n = 1$ and pass allocation to an appropriate
%function internally?} For example
%
%\medskip
%\begin{lstlisting}
%pointer allocate(size_type n)
%{
%  if (n == 1)
%    return foo.allocate(); // Calls node allocation.
%  return bar.allocate(n); // Calls regular allocate.
%}
%\end{lstlisting}
%
%\noindent
%The main reason why this is an undesirable approach is that the
%possibility of having $n \ne 1$ means I have to handle allocations
%with different sizes, which is exactly what I am trying to avoid for
%reasons mentioned above i.e. reduce complexity, improve performance
%etc. Additionally, test for the condition \texttt{if (n == 1)} is
%pointless since it is always true on node allocation.

\noindent
{\bf Node allocation}.  The simplification we are talking about comes from the
fact that there is no more need for an allocation algorithm or any fancy
strategy inside the allocator. We can simply build a singly linked list were
the nodes have the size demanded by the container, then allocation and
deallocation reduces to push and pop from the linked list.

\medskip
\begin{lstlisting}
pointer allocate_node()
{
  pointer q = avail; // The next free node
  if (avail)
    avail = avail->next;

  return q;
}

void deallocate_node(pointer p)
{
  p->next = avail;
  avail = p;
}

\end{lstlisting}

\medskip
\noindent
{\bf Further considerations}: The influence of fragmentation on
performance is well known on the C++ community and subject of many
talks in conferences therefore I am not going to repeat results here
for the sake of readability. The interested reader can refer to
\cite{chandler, meyers} for example.

For an allocator that explores the feature proposed here, please see
the project \cite{rtcpp}. For a general
talk on allocators and why size management is a problem
\cite{alexandrescu}. For related proposal, please see \cite{prop1}.

%\begin{figure}[ht]
%    \centering
%    \subfloat[]{ \includegraphics[scale=0.5]{fig/std_list_bench.png} }
%    \subfloat[]{ \includegraphics[scale=0.5]{fig/std_set_bench.png} }
%        \\
%    \caption[Benchmarks]
%    {Never slower than blah.}
%    \label{fig::bench}
%\end{figure}


\section{Impact on the Standard} \label{impact}

We require the addition of two new member function and
a typedef in \texttt{std::allocator\_traits()} as follows

\medskip
\begin{lstlisting}
template<class Alloc>
struct allocator_traits {
  ...
  // Equal to Alloc::node_allocation_only if present,
  // std::false_type otherwise.
  using node_allocation_only = std::false_type

  // Calls a.allocate_node() if present otherwise calls
  // Alloc::allocate(1). Memory allocate with this function
  // must be deallocated with deallocate_node.
  pointer allocate_node(Alloc& a);

  // Calls a.deallocate_node(pointer) if present otherwise
  // calls Alloc::deallocate(p, 1). Can only be used with
  // memory allocated with allocate_node.
  void deallocate_node(Alloc& a, pointer p);
};
\end{lstlisting}

The typedef \texttt{node\_allocation\_only} is to ensure that
container do not use array allocation on this allocator.
We also propose that all node based containers expose their node types.

The following containers are affected: \texttt{std::forward\_list},
\texttt{std::list}, \texttt{std::set}, \texttt{std::multiset},
\texttt{std::unordered\_set}, \texttt{std::unordered\_multiset},
\texttt{std::map}, \texttt{std::multimap},
\texttt{std::unordered\_map}, \texttt{std::unordered\_multimap}

%\medskip
%\noindent
%{\bf Pure node-based}: As a result of this proposal all node based
%containers mentioned above, with the exception of the unordered ones,
%should support allocators that provide only the overload
%\texttt{allocate()}.
%
\medskip
\noindent
{\bf Unordered containers}: Unordered containers have to rebind twice,
where one type is used for node allocation and one for array allocation.
Let us name these types \texttt{node\_alloc\_type} and \texttt{array\_alloc\_type}.
According to this proposal, \texttt{node\_alloc\_type} is not required to
provide the \texttt{allocate(n)} member whenever \texttt{node\_allocation\_only}
is set to \texttt{std::true\_type()}.

Implementing such allocators for node based containers is easy when we know
the container node type. An example implementation is provided in \cite{rtcpp}.

%\section{Technical Specifications}

\section{Acknowledgment}

I would like thank people that gave me any kind of feedback: Ville Voutilainen,
Nevin Liber, Daniel Gutson, Alisdair Meredith, David Krauss. Special thanks go
to Ion Gaztañaga for suggesting important changes in the original design and David 
Krauss for proposing a different approach.

\begin{thebibliography}{9}

  \bibitem{middleditch} Sean Middleditch, \url{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0038r0.html}
  \bibitem{chandler} Chandler Carruth, {\it Efficiency with Algorithms, Performance
  with Data Structures} (\url{https://www.youtube.com/watch?v=fHNmRkzxHWs})
  \bibitem{meyers} Scott Meyers, {\it Cpu Caches and Why You Care} (\url{https://www.youtube.com/watch?v=WDIkqP4JbkE})
  \bibitem{boost} \url{http://www.boost.org/doc/libs/1_58_0/boost/container/node_allocator.hpp}
  \bibitem{prop1} Ion Gazta\~ naga, \url{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2045.html}
  \bibitem{rtcpp} \url{https://github.com/mzimbres/rtcpp}
  \bibitem{alexandrescu} Andrei Alexandrescu, {\it std::allocator Is to Allocation what
  std::vector Is to Vexation} (\url{https://www.youtube.com/watch?v=LIb3L4vKZ7U})
  \bibitem{embedded} \url{http://www.open-std.org/pipermail/embedded/2014-December/000335.html}
  \bibitem{proplist} \url{https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/ccwOpTxM_xE}
  \bibitem{scary} \url{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2980.pdf}

\end{thebibliography}

\appendix

\section{Alternative approaches} \label{alternative}

There are other possible approaches to support node allocation that are worth knowing
of.  I will list them here, so that the commitee can compare them.

\medskip
\noindent
{\bf Ensure \texttt{allocate(n)} is called with $n = 1$}. This seems the easiest
way to perform node allocation. Once the standard guarantees $n$ will be always $1$,
there is no more need to provide array allocation for node-based containers. The
parameter $n$ can be simply ignored. The \texttt{allocate} and \texttt{deallocate}
can be implemented in terms of node-allocation-only functions, for example
\medskip
\begin{lstlisting}
pointer allocate(std::size_t /* n is ignored */)
{
  return allocate_node();
}

void deallocate_node(pointer p, std::size_t /* n is ignored */)
{
  deallocate_node();
}
\end{lstlisting}

The problem with this approach is that it prevents array allocation inside
node-based containers which means it can be viewed as a narrowing of the
current interface.

\medskip
\noindent
{\bf Provide a \texttt{constexpr max\_size()} that returns 1}. This scheme
can achieve the same goals as my main proposal and does not require any
addition to \texttt{std::allocator\_traits}. Libraries should check if
\texttt{max\_size()} can be evaluated at compile time and take appropriate
action i.e. ensure \texttt{allocate(n)} is always called with $n = 1$.
I did not adopted it due to some disadvantages I see with it

\begin{enumerate}
\item It does not make containers implementation simpler.

\item Function names should reflect that array and node allocation have
different semantics, apart from the storage size. If memory expansion (realloc)
is added in the future, it should only work with storage allocated with
\texttt{allocate(n)} but not with storage allocated for nodes. This allows node
allocations to avoid extra bookeeping data to mark the storage as
non-expandable.

\item It requires the user to specialize \texttt{std::allocator\_traits} to
provide a \texttt{constexpr max\_size()} since the default is not
\texttt{constexpr}. This is not bad but I prefer to avoid it if I can.

\item Other static information like \texttt{propagate\_on\_container\_copy\_assignment}, etc,
are provided as typedef so I prefer to keep the harmony.

\item It sounds more like a hack of the current allocator interface to achieve
node allocation than a full supported feature.

\end{enumerate}


\end{document}

