\documentclass[11pt]{article}
\usepackage{tikz}
\usepackage{pifont}
\usepackage{amsmath}
\usepackage{marvosym}
\usepackage{verbatim}
\usepackage{listings}
\usepackage[utf8]{inputenc}
\usepackage{subfig}
\usepackage[switch,columnwise]{lineno}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage[nottoc,numbib]{tocbibind}
   
\usepackage{hyperref}
\hypersetup{
bookmarks=false,         % show bookmarks bar?
unicode=true,          % non-Latin characters in Acrobat's bookmarks
pdftoolbar=true,        % show Acrobat's toolbar?
pdfmenubar=true,        % show Acrobat's menu?
pdffitwindow=true,     % window fit to page when opened
pdfstartview={FitH},    % fits the width of the page to the window
pdftitle={Node allocators},    % title
pdfauthor={Marcelo Zimbres},     % author
pdfsubject={C++ allocators},   % subject of the document
pdfcreator={Marcelo Zimbres},   % creator of the document
pdfproducer={Marcelo Zimbres}, % producer of the document
pdfkeywords={allocators} {C++}, % list of keywords
pdfnewwindow=true,      % links in new window
colorlinks=true,        % false: boxed links; true: colored links
linkcolor=red,          % color of internal links
citecolor=red,        % color of links to bibliography
filecolor=red,      % color of file links
linktocpage=true,
urlcolor=blue           % color of external links
}

\lstset{
  language=C++,                 % the language of the code
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  keywordstyle=\color{blue},       % keyword style
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{blue},       % comment style
  deletekeywords={},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  morekeywords={using},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=10pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{black}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{red},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\colorlet{blah}{brown!60!black} % box color

\begin{document}

\date{}
\title{\bf Support for \texttt{allocate/deallocate} overloads to
handle same size allocations}

\vspace{-2cm}
\maketitle
%\vspace{-2cm}

%\vspace{1cm}

\noindent
{\bf Document number}:  0 \\
{\bf Date}:  2016-01-05 \\
{\bf Project}: Programming Language C++ Evolution Working Group \\
{\bf Reply-to}: Marcelo Zimbres (\url{mailto:mzimbres@gmail.com}) 

\vspace{1cm}

\noindent
{\bf Abstract: }This is a non-breaking proposal to the C++ standard
that aims to reduce allocator complexity, support realtime allocation
and improve performance on node based containers through the addition
of support for new overloads of the \texttt{allocate} and
\texttt{deallocate} member functions in the allocator interface. An
example implementation that explores the proposed feature is provided
together with benchmarks.

\tableofcontents

\vfill
%\newpage
%\twocolumn
%\linenumbers
\begin{flushright}
\noindent
{\it Size management adds undue difficulties \\
     and inefficiencies to any allocator design.} \\
Alexandrescu \\
\medskip
{\it }
\end{flushright}
\medskip

\section{Introduction}
\textsc{The importance} of linked data structures in computer science,
like trees and linked lists, cannot be over-emphasised, yet, in the
last couple of years it has become a common trend in C++ to move away
from such data structures due to their sub-optimal memory access
patterns.  In fact, many people today prefer to use the flat
alternatives and pay $O(n)$ insertion time than $O(1)$ at the cost of
memory fragmentation and unpredictable performance loss. Other
domains, like {\it realtime applications}, {\it embedded systems} or
systems that aim {\it 24/7 availability}, cannot even afford the
unpredictability introduced by memory fragmentation and dynamic
memory allocations in general.

To address these problems, we propose the addition of support for
\texttt{allocate} and \texttt{deallocate} overloads in allocators
that can only serve one-size memory blocks in node-based containers.

Allocation and deallocation of blocks with the same size is as simple
as pushing and popping from a stack, which, beyond other advantages,
has constant time complexity $O(1)$.

These overloads look like this
\begin{lstlisting}
pointer allocate()
{
  pointer p = stack.pop(); 
  if (!p)
    throw std::bad_alloc();
  return p; 
}

void deallocate(pointer p)
{
  stack.push(p);
}
\end{lstlisting}
which differ from their standard interfaces by the fact
that they do not and cannot manage different allocation sizes.

For related proposal please see \cite{prop1}.

\section{Motivation and scope}

\textsc{Some of} the motivations behind this proposal are
\begin{enumerate}

\item Support the most natural and fastest allocation scheme for
linked data structures. In \texttt{libstd++} and \texttt{libc++}
for example, it is already possible to use this allocation
technique, since $n$ is always $1$ on calls of \texttt{allocate(n)}.

\item Support hard-realtime allocation for node-based containers.
This is highly desirable to improve C++ use in embedded systems.

\item Most allocators found in the literature are overly
complicated as a result of having to handle blocks with different
sizes. In most node-based containers this is unnecessary since the
requested memory has always the same size.

\item State of the art allocators like
\texttt{boost::node\_allocator} achieve great performance gains
optimizing for the $n = 1$ case. 

\item The majority of containers do not manage sizes but pointlessly
demand this feature from their allocator. They are: all ordered
associative containers plus \texttt{std::list} and
\texttt{std::forward\_list} (unordered containers also benefit from
the new overload to allocate the elements in the buckets).

\item Avoid wasted space behind allocations. It is pretty common that
allocators allocate more memory than requested to store informations
like the size of the allocated block.

\item Keep nodes in as-compact-as-possible buffers, either on the
stack or on the heap, improving cache locality, performance and making
them specially useful for embedded programming.

\item This proposal makes it easy to work with pre-allocated and
pre-linked nodes.
\end{enumerate}

\medskip
\noindent
{\bf Frequently asked questions:} Some of the questions commonly
raised are:

\medskip
\noindent
{\bf 1) }{\it Why don't you simply test whether $n = 1$ and pass
allocation to your allocator? For example}
\begin{lstlisting}
pointer allocate(size_type n)
{
  if (n == 1)
    return foo.allocate(); // Calls the node allocator.
  return bar.allocate(n); // Calls regular allocators.
}
\end{lstlisting}

\noindent
There are a couple of reasons why this is an undesirable approach.

\begin{enumerate}
\item The possibility of having $n \ne 1$ means I have to handle
allocations with different sizes, which is exactly what I am
trying to avoid for reasons mentioned above i.e. reduce
complexity, improve performance etc.

\item Containers in major libraries always use $n = 1$, that
means the condition \texttt{if (n == 1)} is an unnecessary
overhead.

\item All that most node-based containers need from their allocator
is space for a single node, asking for more than that means
allocation logic is being built on the container itself an not on
the allocator, with unpredictable side effects that users may
want to avoid.
\end{enumerate}

\medskip
\noindent
{\bf 2) }{\it How does this proposal simplify allocator design?}

\medskip
\noindent
All the simplification comes from the fact that there is no more
need for an allocation algorithm or any fancy strategy inside the
allocator. We can simply build a singly linked list were the
nodes have the size demanded by the container, then allocation
and deallocation reduces to push and pop from the linked list.

\begin{lstlisting}
pointer node_stack::pop()
{
  pointer q = avail; // The next free node
  if (avail)
    avail = avail->next;

  return q;
}

void node_stack::push(pointer p)
{
  p->next = avail;
  avail = p;
}

\end{lstlisting}

\medskip
\noindent
{\bf Benchmarks}: The influence of fragmentation on performance
is well known on the C++ community and subject of many talks in
conferences, therefore I am not going to repeat results here for
the sake of readability. There is plenty of material on CPPCON
for example.  The interested user can also refer the project
\url{https://github.com/mzimbres/rtcpp}
for benchmarks of an allocator that uses the proposed feature.

\section{Impact on the Standard}

\textsc{This proposal} does not require any breaking change. We require
that all node based containers favor the overload \texttt{allocate()}
over \texttt{allocate(size\_type)} for all node allocations inside the
container, whenever this member function is available. The same
reasoning applies to \texttt{deallocate(pointer)} over
\texttt{deallocate(pointer, size\_type)}

In order to know whether the overload is available, users are
requested to add a new member to the specialization of
\texttt{std::allocator\_traits}

\begin{lstlisting}
using use_node_allocator = std::true_type;
\end{lstlisting}

The following containers are affected: \texttt{std::forward\_list},
\texttt{std::list}, \texttt{std::set}, \texttt{std::multiset},
\texttt{std::unordered\_set}, \texttt{std::unordered\_multiset},
\texttt{std::map}, \texttt{std::multimap},
\texttt{std::unordered\_map}, \texttt{std::unordered\_multimap}

\section{Technical Specifications}

\begin{thebibliography}{9}

  \bibitem{prop1} \url{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2045.html}
  \bibitem{rtcpp} \url{https://github.com/mzimbres/rtcpp}
  \bibitem{Alexandrescu} Alexandrescu \url{https://www.youtube.com/watch?v=LIb3L4vKZ7U}
  \bibitem{Chandler} Chandler \url{https://www.youtube.com/watch?v=fHNmRkzxHWs}
  \bibitem{meyers} Meyers \url{https://www.youtube.com/watch?v=WDIkqP4JbkE}
  \bibitem{std} ISOCPP Standard C++ - ISO/IEC JTC1 SC22 WG21 N 3690\newline
    \url{https://isocpp.org/files/papers/N3690.pdf}
  \bibitem{libcxx} libcxx
  \bibitem{libstd} libstd++
  \bibitem{boost} boost

\end{thebibliography}
\end{document}

